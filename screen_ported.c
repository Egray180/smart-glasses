#include <msp430.h>
#include <stdint.h>
#include <stddef.h>

// -----------------------------------------------------------------------------
// ER-OLED0.32-1 (64x32) + SSD1315 over I2C (bit-banged)
// Ported from BuyDisplay sample.c (8051) to MSP430.
//
// Notes:
// - This keeps the same command/data API and higher-level drawing functions as
//   the sample code (OLED_Init, OLED_Clear, OLED_ShowString, etc.).
// - The sample code writes 128 columns per page (SSD1315 RAM is wider than the
//   visible 64px). This port preserves that behavior for compatibility.
// - Can change x_offset / column count later if we want faster updates.
// -----------------------------------------------------------------------------


// ---------------- Pin mapping ----------------
#define OLED_SCL_BIT   BIT6   // P2.6
#define OLED_SDA_BIT   BIT2   // P2.2
#define OLED_RES_BIT   BIT5   // P2.5

#define OLED_PORT_DIR  P2DIR
#define OLED_PORT_OUT  P2OUT
#define OLED_PORT_IN   P2IN
#define OLED_PORT_REN  P2REN

// Using external 10k pull-ups already
#define USE_INTERNAL_PULLUPS 0

// SSD1315 address (8-bit write form) from sample (7-bit 0x3C -> 0x78 write)
#define SSD1315_ADDR_WRITE  0x78

// Control bytes
#define OLED_CTRL_CMD   0x00
#define OLED_CTRL_DATA  0x40

#define OLED_CMD   0
#define OLED_DATA  1

// UART
#define BUFFER_SIZE 500
#define PACKET_SIZE 14 // bytes
#define START_BYTE 255

volatile unsigned char uartBuffer[BUFFER_SIZE]; // circular buffer
volatile unsigned int head = 0;  // index for next write
volatile unsigned int tail = 0;  // index for next read
volatile unsigned int count = 0; // number of bytes in buffer
volatile unsigned int packets = 0; // number of packets to be processed

// -----------------------------------------------------------------------------
// Font + bitmap tables (copied from sample.c, with minor type changes)
// -----------------------------------------------------------------------------
/************************************6*8 accll************************************/
static const uint8_t asc2_0806[][6] ={
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// sp
{0x00, 0x00, 0x00, 0x2f, 0x00, 0x00},// !
{0x00, 0x00, 0x07, 0x00, 0x07, 0x00},// "
{0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14},// #
{0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12},// $
{0x40, 0x26, 0x16, 0x68, 0x64, 0x02},// %
{0x00, 0x36, 0x49, 0x55, 0x22, 0x50},// &
{0x00, 0x00, 0x05, 0x03, 0x00, 0x00},// '
{0x00, 0x00, 0x1c, 0x22, 0x41, 0x00},// (
{0x00, 0x00, 0x41, 0x22, 0x1c, 0x00},// )
{0x00, 0x14, 0x08, 0x3E, 0x08, 0x14},// *
{0x00, 0x08, 0x08, 0x3E, 0x08, 0x08},// +
{0x00, 0x00, 0x00, 0xA0, 0x60, 0x00},// ,
{0x00, 0x08, 0x08, 0x08, 0x08, 0x08},// -
{0x00, 0x00, 0x60, 0x60, 0x00, 0x00},// .
{0x00, 0x20, 0x10, 0x08, 0x04, 0x02},// /
{0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E},// 0
{0x00, 0x00, 0x42, 0x7F, 0x40, 0x00},// 1
{0x00, 0x42, 0x61, 0x51, 0x49, 0x46},// 2
{0x00, 0x21, 0x41, 0x45, 0x4B, 0x31},// 3
{0x00, 0x18, 0x14, 0x12, 0x7F, 0x10},// 4
{0x00, 0x27, 0x45, 0x45, 0x45, 0x39},// 5
{0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30},// 6
{0x00, 0x01, 0x71, 0x09, 0x05, 0x03},// 7
{0x00, 0x36, 0x49, 0x49, 0x49, 0x36},// 8
{0x00, 0x06, 0x49, 0x49, 0x29, 0x1E},// 9
{0x00, 0x00, 0x36, 0x36, 0x00, 0x00},// :
{0x00, 0x00, 0x56, 0x36, 0x00, 0x00},// ;
{0x00, 0x08, 0x14, 0x22, 0x41, 0x00},// <
{0x00, 0x14, 0x14, 0x14, 0x14, 0x14},// =
{0x00, 0x00, 0x41, 0x22, 0x14, 0x08},// >
{0x00, 0x02, 0x01, 0x51, 0x09, 0x06},// ?
{0x00, 0x32, 0x49, 0x59, 0x51, 0x3E},// @
{0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C},// A
{0x00, 0x7F, 0x49, 0x49, 0x49, 0x36},// B
{0x00, 0x3E, 0x41, 0x41, 0x41, 0x22},// C
{0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C},// D
{0x00, 0x7F, 0x49, 0x49, 0x49, 0x41},// E
{0x00, 0x7F, 0x09, 0x09, 0x09, 0x01},// F
{0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A},// G
{0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F},// H
{0x00, 0x00, 0x41, 0x7F, 0x41, 0x00},// I
{0x00, 0x20, 0x40, 0x41, 0x3F, 0x01},// J
{0x00, 0x7F, 0x08, 0x14, 0x22, 0x41},// K
{0x00, 0x7F, 0x40, 0x40, 0x40, 0x40},// L
{0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F},// M
{0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F},// N
{0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E},// O
{0x00, 0x7F, 0x09, 0x09, 0x09, 0x06},// P
{0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E},// Q
{0x00, 0x7F, 0x09, 0x19, 0x29, 0x46},// R
{0x00, 0x46, 0x49, 0x49, 0x49, 0x31},// S
{0x00, 0x01, 0x01, 0x7F, 0x01, 0x01},// T
{0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F},// U
{0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F},// V
{0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F},// W
{0x00, 0x63, 0x14, 0x08, 0x14, 0x63},// X
{0x00, 0x07, 0x08, 0x70, 0x08, 0x07},// Y
{0x00, 0x61, 0x51, 0x49, 0x45, 0x43},// Z
{0x00, 0x00, 0x7F, 0x41, 0x41, 0x00},// [
{0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55},// 55
{0x00, 0x00, 0x41, 0x41, 0x7F, 0x00},// ]
{0x00, 0x04, 0x02, 0x01, 0x02, 0x04},// ^
{0x00, 0x40, 0x40, 0x40, 0x40, 0x40},// _
{0x00, 0x00, 0x01, 0x02, 0x04, 0x00},// '
{0x00, 0x20, 0x54, 0x54, 0x54, 0x78},// a
{0x00, 0x7F, 0x48, 0x44, 0x44, 0x38},// b
{0x00, 0x38, 0x44, 0x44, 0x44, 0x20},// c
{0x00, 0x38, 0x44, 0x44, 0x48, 0x7F},// d
{0x00, 0x38, 0x54, 0x54, 0x54, 0x18},// e
{0x00, 0x08, 0x7E, 0x09, 0x01, 0x02},// f
{0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C},// g
{0x00, 0x7F, 0x08, 0x04, 0x04, 0x78},// h
{0x00, 0x00, 0x44, 0x7D, 0x40, 0x00},// i
{0x00, 0x40, 0x80, 0x84, 0x7D, 0x00},// j
{0x00, 0x7F, 0x10, 0x28, 0x44, 0x00},// k
{0x00, 0x00, 0x41, 0x7F, 0x40, 0x00},// l
{0x00, 0x7C, 0x04, 0x18, 0x04, 0x78},// m
{0x00, 0x7C, 0x08, 0x04, 0x04, 0x78},// n
{0x00, 0x38, 0x44, 0x44, 0x44, 0x38},// o
{0x00, 0xFC, 0x24, 0x24, 0x24, 0x18},// p
{0x00, 0x18, 0x24, 0x24, 0x18, 0xFC},// q
{0x00, 0x7C, 0x08, 0x04, 0x04, 0x08},// r
{0x00, 0x48, 0x54, 0x54, 0x54, 0x20},// s
{0x00, 0x04, 0x3F, 0x44, 0x40, 0x20},// t
{0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C},// u
{0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C},// v
{0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C},// w
{0x00, 0x44, 0x28, 0x10, 0x28, 0x44},// x
{0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C},// y
{0x00, 0x44, 0x64, 0x54, 0x4C, 0x44},// z
{0x14, 0x14, 0x14, 0x14, 0x14, 0x14},// horiz lines

};

//16*16 ASCII
static const uint8_t asc2_1608[][16]={	  
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},/*"!",1*/
{0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
{0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},/*"#",3*/
{0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},/*"$",4*/
{0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},/*"%",5*/
{0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},/*"&",6*/
{0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},/*"(",8*/
{0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},/*")",9*/
{0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},/*"*",10*/
{0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},/*"+",11*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},/*",",12*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},/*"-",13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},/*".",14*/
{0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},/*"/",15*/
{0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},/*"0",16*/
{0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"1",17*/
{0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},/*"2",18*/
{0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},/*"3",19*/
{0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},/*"4",20*/
{0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},/*"5",21*/
{0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},/*"6",22*/
{0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},/*"7",23*/
{0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},/*"8",24*/
{0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},/*"9",25*/
{0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00},/*";",27*/
{0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},/*"<",28*/
{0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},/*"=",29*/
{0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},/*">",30*/
{0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},/*"?",31*/
{0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},/*"@",32*/
{0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},/*"A",33*/
{0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},/*"B",34*/
{0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},/*"C",35*/
{0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},/*"D",36*/
{0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},/*"E",37*/
{0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},/*"F",38*/
{0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},/*"G",39*/
{0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},/*"H",40*/
{0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"I",41*/
{0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},/*"J",42*/
{0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},/*"K",43*/
{0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},/*"L",44*/
{0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},/*"M",45*/
{0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},/*"N",46*/
{0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},/*"O",47*/
{0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},/*"P",48*/
{0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},/*"Q",49*/
{0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},/*"R",50*/
{0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},/*"S",51*/
{0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"T",52*/
{0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"U",53*/
{0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},/*"V",54*/
{0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},/*"W",55*/
{0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},/*"X",56*/
{0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"Y",57*/
{0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},/*"Z",58*/
{0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},/*"[",59*/
{0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},/*"\",60*/
{0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},/*"]",61*/
{0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},/*"_",63*/
{0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
{0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},/*"a",65*/
{0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},/*"b",66*/
{0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},/*"c",67*/
{0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},/*"d",68*/
{0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},/*"e",69*/
{0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"f",70*/
{0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},/*"g",71*/
{0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"h",72*/
{0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"i",73*/
{0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},/*"j",74*/
{0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},/*"k",75*/
{0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"l",76*/
{0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},/*"m",77*/
{0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},/*"n",78*/
{0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"o",79*/
{0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},/*"p",80*/
{0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},/*"q",81*/
{0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},/*"r",82*/
{0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},/*"s",83*/
{0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},/*"t",84*/
{0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},/*"u",85*/
{0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},/*"v",86*/
{0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},/*"w",87*/
{0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},/*"x",88*/
{0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},/*"y",89*/
{0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},/*"z",90*/
{0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},/*"{",91*/
{0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},/*"|",92*/
{0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},/*"}",93*/
{0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"~",94*/
};

static const uint8_t Hzk[][32]={
/*--      :      --*/
/*--      12;         ¶ Ӧ ĵ   Ϊ    x  =16x16   --*/
0x10,0x10,0x10,0xFF,0x10,0xF0,0x00,0x00,0xFE,0x22,0x22,0x22,0x22,0xFE,0x00,0x00,
0x40,0x30,0x0E,0x01,0x00,0x3F,0x40,0x40,0x47,0x44,0x44,0x44,0x44,0x47,0x70,0x00,

/*--      :      --*/
/*--      12;         ¶ Ӧ ĵ   Ϊ    x  =16x16   --*/
0x00,0x00,0x00,0xFE,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0xFE,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3F,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x00,0x00,0x00,

/*--      :      --*/
/*--      12;         ¶ Ӧ ĵ   Ϊ    x  =16x16   --*/
0x00,0x04,0x04,0xC4,0xB4,0x8C,0x87,0x84,0xF4,0x84,0x84,0x84,0x84,0x04,0x00,0x00,
0x00,0x00,0x20,0x18,0x0E,0x04,0x20,0x40,0xFF,0x00,0x02,0x04,0x18,0x30,0x00,0x00,

/*--      :      --*/
/*--      12;         ¶ Ӧ ĵ   Ϊ    x  =16x16   --*/
0x08,0x08,0x08,0x08,0x08,0x08,0xF9,0x4A,0x4C,0x48,0x48,0xC8,0x08,0x08,0x08,0x00,
0x40,0x40,0x20,0x10,0x0C,0x03,0x00,0x00,0x20,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,

/*--      :      --*/
/*--      12;         ¶ Ӧ ĵ   Ϊ    x  =16x16   --*/
0x10,0x12,0x92,0x72,0xFE,0x51,0x91,0x00,0x22,0xCC,0x00,0x00,0xFF,0x00,0x00,0x00,
0x04,0x02,0x01,0x00,0xFF,0x00,0x04,0x04,0x04,0x02,0x02,0x02,0xFF,0x01,0x01,0x00,

/*--      :      --*/
/*--      12;         ¶ Ӧ ĵ   Ϊ    x  =16x16   --*/
0x08,0x08,0x88,0xFF,0x48,0x28,0x00,0xC8,0x48,0x48,0x7F,0x48,0xC8,0x48,0x08,0x00,
0x01,0x41,0x80,0x7F,0x00,0x40,0x40,0x20,0x13,0x0C,0x0C,0x12,0x21,0x60,0x20,0x00,

};

static const uint8_t pic[]=
{
0xFF,0x01,0x01,0x01,0x01,0x01,0x01,0xC1,0xF1,0xFD,0xFD,0x81,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0xC1,0xE1,0xF1,0xF9,0xF9,0xFD,0xFD,0xF9,0xF9,0x61,0xF1,0x51,
0x01,0x09,0x0D,0x0D,0x05,0x09,0x09,0x09,0x09,0x09,0x09,0x99,0xB9,0xC1,0x01,0x01,
0x01,0x81,0x81,0xC1,0xC1,0x81,0x01,0x01,0x01,0x01,0x01,0xFF,0xFF,0x00,0x30,0x30,
0x78,0x7C,0x7F,0x71,0x66,0x60,0x71,0x7F,0x7C,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x07,0x8F,0x7F,0x1F,0x1F,0x3F,0x7F,0xFE,0xFE,0xFA,0xF3,0xF6,0xF6,0xC4,0x48,0x18,
0x18,0x78,0xF8,0xF8,0xF8,0xFC,0xF4,0xF4,0xEF,0xE8,0x99,0x71,0x06,0x1F,0xFF,0xFF,
0xFF,0xFF,0x7F,0x3E,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xC0,0x23,0x7C,0x48,0x48,0x88,0x78,0x30,0x0C,0xE3,0xF0,0xF8,
0xFC,0x1E,0x4E,0x4E,0x6F,0xDF,0x7D,0x31,0x01,0x00,0x00,0x00,0xC0,0xB0,0x98,0x99,
0x39,0xF9,0xF9,0xF9,0xF1,0xE1,0xC0,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
0x87,0x88,0x98,0x90,0x90,0xBF,0xF8,0xE0,0xC0,0x83,0x87,0x8F,0x8F,0x8E,0x8C,0x84,
0x8E,0x8C,0x88,0x80,0x80,0x80,0x80,0x80,0x80,0x84,0x8C,0x9D,0x9D,0xBF,0xBF,0xBF,
0xBF,0x9F,0x8F,0x80,0x80,0x80,0xE0,0xBF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,
};

static const uint8_t pic1[]=
{
0x00,0x00,0x00,0xE0,0x70,0x70,0x38,0xFE,0xFE,0xFE,0x00,0x00,0x00,0x00,0x18,0x1C,
0x1E,0x0E,0x06,0x06,0x8E,0xFE,0xFC,0x78,0x00,0x00,0x00,0xE0,0xE0,0xE0,0x00,0x00,
0x00,0x18,0x1C,0x1E,0x86,0x86,0xC6,0xFE,0xFC,0x78,0x00,0x00,0x00,0x00,0x80,0xC0,
0x70,0x3C,0xFE,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF8,0xFC,0xDE,0xCF,
0xC7,0xC3,0xC1,0xC0,0x00,0x00,0x00,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x30,0x70,0xF0,
0xE1,0xC1,0xC1,0xE3,0x7F,0x7E,0x1C,0x00,0x1C,0x1E,0x1B,0x19,0x18,0x18,0xFF,0xFF,
0xFF,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0xC0,0x00,0xC0,0xF0,
0xF0,0xF0,0x00,0x80,0x40,0x40,0x40,0xC0,0x80,0x00,0xC0,0xC0,0x40,0x40,0x00,0x00,
0x20,0x30,0x10,0x10,0xF0,0xE0,0x00,0xE0,0xF0,0x10,0x10,0xF0,0xE0,0x00,0x00,0x00,
0x00,0x00,0xF0,0xF0,0x10,0x10,0x10,0x00,0xF0,0xF0,0x10,0x10,0x10,0xF0,0xE0,0x00,
0x00,0xF0,0xF0,0x00,0x00,0x1F,0x1F,0x00,0x0F,0x1C,0x0F,0x00,0x1F,0x1F,0x00,0x0C,
0x1E,0x13,0x11,0x1F,0x1F,0x00,0x1F,0x1F,0x00,0x00,0x00,0x00,0x18,0x1C,0x16,0x13,
0x11,0x10,0x00,0x0E,0x1F,0x11,0x11,0x1F,0x0E,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,
0x01,0x01,0x01,0x00,0x1F,0x1F,0x01,0x01,0x03,0x0F,0x1C,0x10,0x00,0x1F,0x1F,0x00,
};

static const uint8_t pic2[]=
{
0xF8,0x08,0x08,0xF8,0x08,0x08,0xF0,0x00,0xF8,0x88,0x88,0x70,0x00,0x44,0x82,0x92,
0x6C,0x00,0xF8,0x08,0x08,0xF8,0x08,0x08,0xF0,0x00,0x70,0xA8,0xA8,0xB0,0x00,0x70,
0x88,0x88,0xFE,0x00,0xFA,0x00,0xC8,0xA8,0xA8,0xF8,0x00,0xF8,0x88,0x88,0x70,0x00,
0xFE,0x00,0xC8,0xA8,0xA8,0xF8,0x00,0x08,0x70,0x80,0x70,0x08,0x00,0x00,0x00,0xF8,
0xF0,0xE0,0xC0,0x80,0x03,0x00,0xF0,0x00,0xC0,0x40,0x40,0x80,0x00,0x00,0x00,0x00,
0xC0,0x40,0x40,0xC0,0x40,0x40,0x80,0x00,0x40,0x80,0x00,0x80,0x40,0x00,0x00,0x00,
0x00,0xF0,0x40,0x40,0x80,0x00,0x80,0x43,0x40,0x80,0x00,0x40,0x40,0x40,0xC0,0x00,
0xC0,0x40,0x40,0xE0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x0F,0x07,0x03,0x01,0x00,
0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x07,
0x00,0x00,0x07,0x00,0x00,0x13,0x0C,0x03,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,
0x07,0x00,0x03,0x05,0x05,0x05,0x00,0x06,0x05,0x05,0x07,0x00,0x07,0x00,0x00,0x07,
0x04,0x00,0x00,0x00,0x3E,0x41,0x41,0x3E,0x00,0x02,0x7F,0x00,0x44,0x00,0x2C,0x47,
0x45,0x39,0x00,0x42,0x61,0x59,0x46,0x00,0x60,0x1C,0x03,0x22,0x41,0x49,0x36,0x00,
0x00,0x44,0x00,0x2C,0x47,0x45,0x39,0x00,0x36,0x49,0x49,0x36,0x00,0x00,0x3E,0x3E,
0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x3E,

};

static const uint8_t pic3[]=
{
0x07,0xE1,0x21,0x21,0x30,0x28,0x20,0x20,0x20,0xE0,0x00,0x00,0x00,0x00,0xF8,0x88,
0x88,0x88,0x88,0x88,0x88,0xF8,0x00,0x00,0x80,0xC0,0x38,0x20,0x20,0xA0,0x78,0xA0,
0x20,0xB0,0x20,0x00,0x00,0xC0,0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0xC0,0x00,0x00,
0x00,0x00,0xF8,0x48,0x48,0x48,0xC8,0x48,0x49,0x79,0x01,0x07,0x00,0x3F,0x22,0x22,
0x22,0x22,0x22,0x22,0x22,0x3F,0x00,0x00,0x00,0x00,0x3F,0x10,0x10,0x10,0x10,0x10,
0x10,0x3F,0x00,0x00,0x00,0x3F,0x00,0x02,0x01,0x3F,0x10,0x03,0x0D,0x10,0x20,0x00,
0x00,0x1F,0x10,0x10,0x10,0x1F,0x10,0x10,0x10,0x3F,0x00,0x00,0x08,0x04,0x03,0x10,
0x12,0x14,0x24,0x21,0x02,0x04,0x04,0x00,0x10,0x14,0xD4,0x5E,0x54,0xF4,0x54,0x5E,
0xD4,0x14,0x10,0x00,0x12,0xA4,0x70,0x04,0xF4,0x14,0x14,0xF4,0x04,0xFE,0x04,0x00,
0x00,0x00,0x00,0x82,0x62,0x1C,0x60,0x80,0x00,0x00,0x00,0x00,0x32,0xC4,0xB0,0x88,
0xF6,0x94,0xD4,0x94,0x94,0xF4,0x84,0x00,0x22,0x4C,0xE0,0x04,0xA4,0x34,0xAE,0x24,
0xB4,0x64,0x04,0x00,0xE8,0x88,0x8F,0x85,0x05,0x07,0x05,0x05,0x0F,0x08,0x08,0x00,
0x02,0x0F,0x00,0x00,0x01,0x01,0x01,0x09,0x08,0x0F,0x00,0x00,0x08,0x04,0x02,0x01,
0x00,0x00,0x00,0x01,0x02,0x04,0x08,0x00,0x0F,0x00,0x00,0x03,0x02,0x02,0x0B,0x0A,
0x0F,0x02,0x02,0x00,0x02,0x0F,0x08,0x04,0x03,0x00,0x0F,0x00,0x8F,0x88,0x8E,0xE0,
};

// 12x16 arrow head, page-major (2 pages × 12 columns)
const unsigned char arrow_head_right_12x16[24] = {
  0x08,0x14,0x24,0x48,0x88,0x10,0x10,0x20,0x20,0x40,0x40,0x80,
  0x08,0x14,0x12,0x09,0x08,0x04,0x04,0x02,0x02,0x01,0x01,0x00
};

const unsigned char arrow_head_left_12x16[24] = {
  0x80,0x40,0x40,0x20,0x20,0x10,0x10,0x88,0x48,0x24,0x14,0x08,
  0x00,0x01,0x01,0x02,0x02,0x04,0x04,0x08,0x09,0x12,0x14,0x08
};

// -----------------------------------------------------------------------------
// Delay helpers (conservative / slow, fine for bring-up)
// -----------------------------------------------------------------------------
static void delay_cycles_const(uint16_t nBlocks)
{
    while (nBlocks--)
        __delay_cycles(1000);
}

static void delay_ms(uint16_t ms)
{
    // DCO ~5.33 MHz => ~5330 cycles/ms, use ~5000 cycles/ms
    while (ms--)
        delay_cycles_const(5);
}

static void delay_s(uint16_t s)
{
    while (s--)
        delay_ms(1000);
}

// I2C edge timing: ~10 us-ish (very conservative / slow)
static void delay_short(void)
{
    __delay_cycles(100);
}

// -----------------------------------------------------------------------------
// Open-drain helpers (drive low by DIR=1+OUT=0; release by DIR=0)
// -----------------------------------------------------------------------------
static void SCL_low(void)      { OLED_PORT_OUT &= ~OLED_SCL_BIT; OLED_PORT_DIR |=  OLED_SCL_BIT; }
static void SCL_release(void)  { OLED_PORT_DIR &= ~OLED_SCL_BIT; }

static void SDA_low(void)      { OLED_PORT_OUT &= ~OLED_SDA_BIT; OLED_PORT_DIR |=  OLED_SDA_BIT; }
static void SDA_release(void)  { OLED_PORT_DIR &= ~OLED_SDA_BIT; }

static uint8_t SDA_read(void)  { return (OLED_PORT_IN & OLED_SDA_BIT) ? 1 : 0; }

// -----------------------------------------------------------------------------
// I2C bit-bang
// -----------------------------------------------------------------------------
static void i2c_idle(void)
{
    SDA_release();
    SCL_release();
    delay_short();
}

static void i2c_start(void)
{
    SDA_release();
    SCL_release();
    delay_short();

    SDA_low();
    delay_short();

    SCL_low();
    delay_short();
}

static void i2c_stop(void)
{
    SDA_low();
    delay_short();

    SCL_release();
    delay_short();

    SDA_release();
    delay_short();
}

static void i2c_write_bit(uint8_t bit)
{
    if (bit) SDA_release();
    else     SDA_low();

    delay_short();
    SCL_release();
    delay_short();
    SCL_low();
    delay_short();
}

static uint8_t i2c_read_ack(void)
{
    uint8_t ack;

    SDA_release();          // release so OLED can pull low
    delay_short();

    SCL_release();          // clock high for ACK bit
    delay_short();

    ack = (SDA_read() == 0); // ACK = SDA low

    SCL_low();
    delay_short();

    return ack;
}

static uint8_t i2c_write_byte(uint8_t b)
{
    uint8_t i;
    for (i = 0; i < 8; i++)
    {
        i2c_write_bit((b & 0x80u) != 0);
        b <<= 1;
    }
    return i2c_read_ack();
}

// -----------------------------------------------------------------------------
// OLED low-level write helpers
// -----------------------------------------------------------------------------
static uint8_t oled_write_byte(uint8_t control, uint8_t data)
{
    uint8_t ok;

    i2c_start();

    ok = i2c_write_byte(SSD1315_ADDR_WRITE);
    if (!ok) { i2c_stop(); return 0; }

    ok = i2c_write_byte(control);
    if (!ok) { i2c_stop(); return 0; }

    ok = i2c_write_byte(data);

    i2c_stop();
    return ok;
}

// Write multiple DATA bytes in one I2C transaction (much faster for clears/BMPs)
static uint8_t oled_write_data_bytes(const uint8_t *data, size_t len)
{
    uint8_t ok;

    i2c_start();

    ok = i2c_write_byte(SSD1315_ADDR_WRITE);
    if (!ok) { i2c_stop(); return 0; }

    ok = i2c_write_byte(OLED_CTRL_DATA);
    if (!ok) { i2c_stop(); return 0; }

    size_t i;
    for (i = 0; i < len; i++)
    {
        ok = i2c_write_byte(data[i]);
        if (!ok) { i2c_stop(); return 0; }
    }

    i2c_stop();
    return 1;
}

static uint8_t oled_cmd(uint8_t cmd)  { return oled_write_byte(OLED_CTRL_CMD,  cmd); }
static uint8_t oled_data(uint8_t dat) { return oled_write_byte(OLED_CTRL_DATA, dat); }

// -----------------------------------------------------------------------------
// GPIO + Reset 
// -----------------------------------------------------------------------------
static void oled_gpio_init(void)
{
#ifdef PM5CTL0
    PM5CTL0 &= ~LOCKLPM5; // unlock GPIO from high-Z
#endif

    // Prepare outputs low
    OLED_PORT_OUT &= ~(OLED_SCL_BIT | OLED_SDA_BIT | OLED_RES_BIT);

    // RES push-pull output
    OLED_PORT_DIR |= OLED_RES_BIT;

#if USE_INTERNAL_PULLUPS
    OLED_PORT_REN |=  (OLED_SCL_BIT | OLED_SDA_BIT);
    OLED_PORT_OUT |=  (OLED_SCL_BIT | OLED_SDA_BIT); // pull-up
#else
    OLED_PORT_REN &= ~(OLED_SCL_BIT | OLED_SDA_BIT);
#endif

    // RES high
    OLED_PORT_OUT |= OLED_RES_BIT;

    // I2C idle released
    i2c_idle();
}

static void oled_reset_pulse(void)
{
    OLED_PORT_OUT &= ~OLED_RES_BIT; // RES low
    delay_ms(50);
    OLED_PORT_OUT |= OLED_RES_BIT;  // RES high
    delay_ms(50);
}

// -----------------------------------------------------------------------------
// High-level API (ported 1:1 from sample.c)
// -----------------------------------------------------------------------------

// x_offset matches the sample code (module-specific column mapping)
static uint8_t x_offset = 0x22;

void OLED_WR_Byte(uint8_t dat, uint8_t mode)
{
    if (mode == OLED_DATA) (void)oled_data(dat);
    else                  (void)oled_cmd(dat);
}

void OLED_ColorTurn(uint8_t i)
{
    if (i == 0) OLED_WR_Byte(0xA6, OLED_CMD); // normal
    if (i == 1) OLED_WR_Byte(0xA7, OLED_CMD); // inverse
}

void OLED_DisplayTurn(uint8_t i)
{
    if (i == 0)
    {
        OLED_WR_Byte(0xC8, OLED_CMD);
        OLED_WR_Byte(0xA1, OLED_CMD);
    }
    if (i == 1)
    {
        OLED_WR_Byte(0xC0, OLED_CMD);
        OLED_WR_Byte(0xA0, OLED_CMD);
    }
}

void OLED_Set_Pos(uint8_t x, uint8_t y)
{
    
    uint8_t col = x + x_offset; 

    OLED_WR_Byte(0xB0 + y, OLED_CMD);
    OLED_WR_Byte(0x10 | (col >> 4), OLED_CMD);
    OLED_WR_Byte(col & 0x0F, OLED_CMD);
}

void OLED_Display_On(void)
{
    OLED_WR_Byte(0x8D, OLED_CMD);  // Charge Pump Setting
    OLED_WR_Byte(0x14, OLED_CMD);  // Enable
    OLED_WR_Byte(0xAF, OLED_CMD);  // Display ON
}

void OLED_Display_Off(void)
{
    OLED_WR_Byte(0x8D, OLED_CMD);  // Charge Pump Setting
    OLED_WR_Byte(0x10, OLED_CMD);  // Disable
    OLED_WR_Byte(0xAE, OLED_CMD);  // Display OFF
}

void OLED_Clear(void)
{
    // Use a small zero buffer and stream it repeatedly.
    static const uint8_t zeros[16] = {0};

    uint8_t page;
    for (page = 0; page < 4; page++)
    {
        OLED_WR_Byte(0xB0 + page, OLED_CMD);
        uint8_t col = x_offset;
        OLED_WR_Byte(col & 0x0F, OLED_CMD);
        OLED_WR_Byte(0x10 | (col >> 4), OLED_CMD);

        // Sample code clears 128 columns per page
        uint8_t n; 
        for (n = 0; n < 8; n++)
        {
            (void)oled_write_data_bytes(zeros, sizeof(zeros)); // 8*16 = 128 bytes
        }
    }
}


void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t sizey)
{
    uint8_t c = 0, sizex = sizey / 2;
    uint16_t i = 0, size1;

    if (sizey == 8) size1 = 6;
    else size1 = (sizey / 8 + ((sizey % 8) ? 1 : 0)) * (sizey / 2);

    c = chr - ' ';
    OLED_Set_Pos(x, y);

    for (i = 0; i < size1; i++)
    {
        if (i % sizex == 0 && sizey != 8) OLED_Set_Pos(x, y++);
        if (sizey == 8)       OLED_WR_Byte(asc2_0806[c][i], OLED_DATA);   // 6x8
        else if (sizey == 16) OLED_WR_Byte(asc2_1608[c][i], OLED_DATA);   // 8x16
        else return;
    }
}

uint16_t oled_pow(uint8_t m, uint8_t n)
{
    uint16_t result = 1;
    while (n--) result *= m;
    return result;
}

void OLED_ShowNum(uint8_t x, uint8_t y, uint16_t num, uint8_t len, uint8_t sizey)
{
    uint8_t t, temp, m = 0;
    uint8_t enshow = 0;

    if (sizey == 8) m = 2;

    for (t = 0; t < len; t++)
    {
        temp = (num / oled_pow(10, len - t - 1)) % 10;
        if (enshow == 0 && t < (len - 1))
        {
            if (temp == 0)
            {
                OLED_ShowChar(x + (sizey / 2 + m) * t, y, ' ', sizey);
                continue;
            }
            else enshow = 1;
        }
        OLED_ShowChar(x + (sizey / 2 + m) * t, y, temp + '0', sizey);
    }
}

void OLED_ShowString(uint8_t x, uint8_t y, const uint8_t *chr, uint8_t sizey)
{
    uint8_t j = 0;
    while (chr[j] != '\0')
    {
        OLED_ShowChar(x, y, chr[j++], sizey);
        if (sizey == 8) x += 6;
        else x += sizey / 2;
    }
}

void OLED_ShowChinese(uint8_t x, uint8_t y, uint8_t no, uint8_t sizey)
{
    uint16_t i, size1 = (sizey / 8 + ((sizey % 8) ? 1 : 0)) * sizey;
    for (i = 0; i < size1; i++)
    {
        if (i % sizey == 0) OLED_Set_Pos(x, y++);
        if (sizey == 16) OLED_WR_Byte(Hzk[no][i], OLED_DATA); // 16x16
        else return;
    }
}

void OLED_DrawBMP(uint8_t x, uint8_t y, uint8_t sizex, uint8_t sizey, const uint8_t *BMP)
{
    uint16_t j = 0;
    uint8_t i, m;

    sizey = sizey / 8 + ((sizey % 8) ? 1 : 0);
    for (i = 0; i < sizey; i++)
    {
        OLED_Set_Pos(x, i + y);
        for (m = 0; m < sizex; m++)
        {
            OLED_WR_Byte(BMP[j++], OLED_DATA);
        }
    }
}

void OLED_Init(void)
{
    oled_gpio_init();
    oled_reset_pulse();
    delay_s(3); // time to turn on VCC for testing

    OLED_WR_Byte(0xAE, OLED_CMD); // display off
    OLED_WR_Byte(0xD5, OLED_CMD); // clock divide
    OLED_WR_Byte(0x80, OLED_CMD); // suggested
    OLED_WR_Byte(0xA8, OLED_CMD); // multiplex ratio
    OLED_WR_Byte(0x1F, OLED_CMD); // 1/32 duty
    OLED_WR_Byte(0xD3, OLED_CMD); // display offset
    OLED_WR_Byte(0x00, OLED_CMD); // no offset
    OLED_WR_Byte(0x00, OLED_CMD); // start line = 0

    //OLED_WR_Byte(0x8D, OLED_CMD); // charge pump
    //OLED_WR_Byte(0x14, OLED_CMD); // enable
    OLED_WR_Byte(0xA1, OLED_CMD); // segment remap
    OLED_WR_Byte(0xC8, OLED_CMD); // COM scan direction
    OLED_WR_Byte(0xDA, OLED_CMD); // COM pins config
    OLED_WR_Byte(0x12, OLED_CMD);
    OLED_WR_Byte(0x81, OLED_CMD); // contrast
    OLED_WR_Byte(0x18, OLED_CMD);
    OLED_WR_Byte(0xD9, OLED_CMD); // pre-charge
    OLED_WR_Byte(0xF1, OLED_CMD);
    OLED_WR_Byte(0xDB, OLED_CMD); // vcomh
    OLED_WR_Byte(0x40, OLED_CMD);
    OLED_WR_Byte(0xA4, OLED_CMD); // resume RAM display

    OLED_Clear();
    OLED_WR_Byte(0xAF, OLED_CMD); // display on
    delay_ms(150);
}

// ---------------- Clock setup ----------------
static void clock_init_dco_default(void)
{
    CSCTL0_H = CSKEY_H;
    //CSCTL1 |= DCORSEL;
    //CSCTL1 = DCOFSEL_0;  // ~5.33 MHz on MSP430FR5739
    CSCTL1 = DCOFSEL0 + DCOFSEL1; // 8 MHz
    CSCTL2 = SELA__VLOCLK | SELS__DCOCLK | SELM__DCOCLK;
    CSCTL3 = DIVA__1 | DIVS__1 | DIVM__1;
    CSCTL0_H = 0;
}

void uart_setup() {
    // Configure ports for UART
	P2SEL0 &= ~(BIT0 + BIT1);
	P2SEL1 |= BIT0 + BIT1;

	// Configure UART0
	UCA0CTLW0 |= UCSWRST;
    //UCA0CTLW0 |= UCSSEL0;                   // Run the UART using ACLK
    UCA0CTLW0 |= UCSSEL1;                   // Run the UART using SMCLK
	UCA0MCTLW = UCOS16 + UCBRF0 + 0x4900;   // Baud rate = 9600 from an 8 MHz clock
	UCA0BRW = 52;
	UCA0CTLW0 &= ~UCSWRST;
    
	UCA0IE |= UCRXIE;                       // Enable UART Rx interrupt
}

void sendUARTChar(unsigned char c)
{
    while(!(UCA0IFG & UCTXIFG)) UCA0TXBUF=c;
}

void sendUARTString(const char *str)
{
    while(*str) sendUARTChar(*str++);
}

void sendUARTInt(unsigned int value)
{
    char buf[6]; int i=0;
    if(value==0){ sendUARTChar('0'); return; }
    while(value>0){ buf[i++]=(value%10)+'0'; value/=10; }
    while(i-->0) sendUARTChar(buf[i]);
}

// ====== Helpers ======	
static void unpack_two_digits(uint8_t b, uint8_t *tensChar, uint8_t *onesChar)
{
    uint8_t tens = (uint8_t)(b / 10);
    uint8_t ones = (uint8_t)(b % 10);

    if (tens > 9) tens = 0;
    if (ones > 9) ones = 0;

    *tensChar = '0' + tens;
    *onesChar = '0' + ones;
}

// Writes unsigned integer v (0..999) into out with no leading zeros.
// Returns number of chars written (no null terminator).
static int utoa_no_leading_zeros(unsigned int v, uint8_t *out)
{
    if (v == 0) { out[0] = '0'; return 1; }

    uint8_t tmp[5];
    int n = 0;
    while (v > 0 && n < 4)
    {
        tmp[n++] = '0' + (v % 10);
        v /= 10;
    }
    int i;
    for (i = 0; i < n; i++)
        out[i] = tmp[n - 1 - i];

    return n;
}

// out must be big enough (recommend >= 16)
static void build_distance_string(uint8_t dist1, uint8_t dist2, uint8_t unit01, uint8_t *out)
{
    int idx = 0;

    if (unit01 == 0)
    {
        // -------- METERS --------
        // dist1: thousands/hundreds, dist2: tens/ones (two digits per byte)
        uint8_t d0, d1, d2, d3;
        unpack_two_digits(dist1, &d0, &d1);
        unpack_two_digits(dist2, &d2, &d3);

        uint8_t digits[4] = { d0, d1, d2, d3 };

        // Strip leading zeros, keep at least one digit
        int started = 0;
        int i;
        for (i = 0; i < 4; i++)
        {
            if (!started)
            {
                if (digits[i] != '0' || i == 3) started = 1;
                else continue;
            }
            out[idx++] = digits[i];
        }

        out[idx++] = ' ';
        out[idx++] = 'm';
        out[idx]   = '\0';
        return;
    }
    else if (unit01 == 1)
    {
        // -------- KILOMETERS --------
        // dist1: integer km part (0..254)
        // dist2: decimals
        idx += utoa_no_leading_zeros(dist1, &out[idx]);

        uint8_t tenths = 0;
        uint8_t hundredths = 0;

        if (dist2 < 10)
        {
            tenths = dist2;      // 5 => .5
            hundredths = 0;
        }
        else
        {
            tenths = (uint8_t)(dist2 / 10);     // 55 => 5
            hundredths = (uint8_t)(dist2 % 10); // 55 => 5
        }

        if (!(tenths == 0 && hundredths == 0))
        {
            out[idx++] = '.';
            out[idx++] = '0' + (tenths % 10);
            if (hundredths != 0) // trim trailing zero
                out[idx++] = '0' + (hundredths % 10);
        }

        out[idx++] = ' ';
        out[idx++] = 'k';
        out[idx++] = 'm';
        out[idx]   = '\0';
        return;
    }
    else
    {
        // Unknown unit
        out[0] = '?';
        out[1] = '\0';
    }
}

// out must be >= 9 (8 chars + null)
static void build_street_string(const uint8_t *streetBytes8, uint8_t *out)
{
    int idx = 0;
    int i;
    for (i = 0; i < 8; i++)
    {
        uint8_t c = streetBytes8[i];
        if (c == 0) break;           // treat 0 as terminator
        out[idx++] = c;
    }
    out[idx] = '\0';
}

int main(void) {
    WDTCTL = WDTPW | WDTHOLD;

    P3DIR |= BIT4; // LED to check ack
    P3OUT &= ~BIT4; 


    clock_init_dco_default();
    uart_setup();
    delay_ms(200);

    OLED_Init();

    __enable_interrupt();       // Enable global interrupts

    OLED_ShowString(0,0,"Welcome",8);
    OLED_ShowString(0,1,"to",8);
    OLED_ShowString(0,2,"EYEWHERE",8);
    //OLED_ShowString(0,3,"",8);

    // preallocated strings
    uint8_t distanceString[16];
    uint8_t streetString[9];

    while (1) {
        if (packets > 0) {
            if (uartBuffer[tail] == START_BYTE)
            {
                unsigned int index = tail;
                tail = (tail + 1) % BUFFER_SIZE;

                // direction arrow
                uint8_t dir = uartBuffer[tail]; // 1 is left 2 is right
                tail = (tail + 1) % BUFFER_SIZE;

                // distance bytes + unit
                uint8_t dist1 = uartBuffer[tail];
                tail = (tail + 1) % BUFFER_SIZE;
                uint8_t dist2 = uartBuffer[tail];
                tail = (tail + 1) % BUFFER_SIZE;
                uint8_t unit  = uartBuffer[tail]; // 0=m, 1=km
                tail = (tail + 1) % BUFFER_SIZE;

                // street name bytes (8)
                uint8_t streetBytes[8];
                int i;
                for (i = 0; i < 8; i++) {
                    streetBytes[i] = uartBuffer[tail];
                    tail = (tail + 1) % BUFFER_SIZE;
                }

                // special message
                uint8_t special = uartBuffer[tail];
                tail = (tail + 1) % BUFFER_SIZE;

                // create strings
                build_distance_string(dist1, dist2, unit, distanceString);
                build_street_string(streetBytes, streetString);

                // ---- Now you would call your OLED functions (not implemented here) ----
                // Example placeholders:
                // OLED_DrawArrow(dir);
                // OLED_DrawString_Page(2, /*x*/0, distanceString);
                // OLED_DrawString_Page(3, /*x*/0, streetString);
                // OLED_HandleSpecial(special);


                OLED_Clear();
                if (dir == 1) {
                    //OLED_ShowString(0,0,"Left",8);
                    OLED_DrawBMP(0,0,12,16,arrow_head_left_12x16);
                }
                else {
                    //OLED_ShowString(0,0,"Right",8);
                    OLED_DrawBMP(0,0,12,16,arrow_head_right_12x16);
                }

                OLED_ShowString(0,2,distanceString,8);
                OLED_ShowString(0,3,streetString,8);

                //(void)dir;
                //(void)special;

                // echo packet back for debugging
                for (i = 0; i < PACKET_SIZE; i++)

                    sendUARTChar(uartBuffer[(index+i)%BUFFER_SIZE]);
            }
            packets--;
            count -= PACKET_SIZE;
        } 
    }
}

#pragma vector = USCI_A0_VECTOR
__interrupt void USCI_A0_ISR(void)
{
    switch (__even_in_range(UCA0IV, 4))
    {
    case 0: break;                 // No interrupt
    case 2:                        // RXIFG
        {
            unsigned int rx = UCA0RXBUF;   // Read received byte
            uartBuffer[head] = rx;
            head = (head + 1) % BUFFER_SIZE;
            if (count < BUFFER_SIZE) count++; // otherwise overflow

            if (count >= PACKET_SIZE) {
                packets = count / PACKET_SIZE;
            }

        }
        break;
    case 4: break;                 // TXIFG (not used)
    default: break;
    }
}
